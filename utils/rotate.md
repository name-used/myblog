# 旋转-缩放通用工具库

设计目的：
  实现以任意角度、任意缩放进行原图采样[1]的通用工具
  
子结构：
  1. 旋转缩放算法
  2. 接口设计
  3. 容差矫正

## 一、旋转缩放算法

事实上，图像的旋转变换是一个非常简单的数学运算，同时，早已有大量现成的工具库可以使用[2]。

首先让我们回到高中，设 XOY 平面上有坐标点 P0=(x0, y0)，我们知道它可以用极坐标表示为 P =（r, a），并满足：
```
x0 = r * cosa, y0 = r * sina, r = sqrt(x0*x0 + y0*y0), a = arctan(y0/x0)
```
现令 P0 绕原点逆时针旋转至 P=(x,y) 处，不妨设旋转角度 e，则其极坐标为 P=（r, a+e），由坐标间对应关系可知，其依然满足：
```
x = r * cos(a+e), y = r * sin(a+e)
```
我们将三角函数展开，可得如下表达式：
```
x = r * cosa * cose - r * sina * sine
y = r * sina * cose + r * cosa * sine
```
由几何关系不难发现，上式中的 r * sina 恰表示 y0；r * cosa 恰表示 x0，因此进一步简化，得：
```
x = x0 * cose - y0 * sine
y = y0 * cose + x0 * sine
```
现在让我们进入大学，学过线性代数或高等代数的人显然不会对上式感到陌生，这是一个典型的线性变换，可记作：
```
P = A × P0
其中，A = [
  cose   -sine
  sine    cose
]
```
式中， P(x,y) 随 P0(x0,y0) 变化，变化法则被矩阵 A 所唯一确定，类似这样的变换统一称为 “仿射变换” -> Affine，显然，旋转是一种仿射变换，但仿射变换不止包含旋转，事实上，本工具库可以封装任何类型的仿射变换，但本人只用到了旋转和缩放，因此对其它变换未提供支持。

接着让我们进入码农们的世界，前文提到，图像的旋转变化早已有大量的现成的工具库可以使用，其中最著名的工具当之无愧是 opencv，它可以通过这样的代码旋转一张图片：
```
cv2.rotate(src=image, rotateCode=cv2.ROTATE_90_COUNTERCLOCKWISE)
或
M = cv2.getRotationMatrix2D(center=(x0, y0), degree=90, scale=1)
cv2.warpAffine(src=img, M=M, dsize=(h, w))
```
只是看到这样糟糕的代码封装，大概你就能意识到为何我会放弃它，而选择手写一个旋转函数了：
  1. opencv 作为原生于 C++ 语言的工具库，其封装语法更接近程式性语言，而非面向对象或函数式的
  2. opencv 显式支持的 rotate 函数只提供 90° 旋转的功能
  3. opencv 通过仿射矩阵隐式支持旋转算法需要自行补充计算大量的外围参数
  4. 综上，手写一个旋转算法并不比直接应用 opencv 麻烦多少，性能上反而可能更高（这将在下文计算时间复杂度时进行解释）

在继续之前，先让我们来熟悉一下 python 中的另一个神级工具库：numpy。numpy 同样是 c++ 写成的第三方工具库，不同之处在于，它是完全以 python 语法为基础进行封装的，这意味着它的使用更加便捷与灵活，尤为重要的是，它定义了一种全新的python规范，这种规范被广泛接纳于全部与 python 有关的代数计算领域，应该说，很少能见到不依赖于 numpy 的科学计算工具库，当然，包括opencv也是 -> 它的参数、返回值都是 numpy.ndarray 类型。

让我们来对比一下 numpy 和原生 python 之间的异同
```
# ----------------- 原生 ------------------
arr1 = list(range(1000))
arr2 = arr1 + arr1
# 列表相加 len(arr2) == 2 * len(arr1)
arr3 = arr1 * 5
# 列表数乘 len(arr2) == 5 * len(arr1)
arr4 = [
  [1, 2],
  [3, 4],
]
# 二维列表取值 arr4[0][1]
arr5 = arr1[1:-1]
# 切片取值 len(arr5) == len(arr1) - 2
arr1[1:-1] = []
# 切片赋值 len(arr1) == 2

# ----------------- numpy ------------------
brr1 = np.array(range(1000))
brr2 = brr1 + brr1
# 数组相加 brr2 -> {0, 2,4,6,...}
brr3 = brr1 * 5
# 数组数乘 brr3 -> {0, 5,10,15,...}
brr4 = np.array([
  [1, 2],
  [3, 4],
])
# 二维数组取值 brr4[0, 1]
brr5 = brr1[1:-1]
# 切片取值 len(brr5) == len(brr1) - 2
brr1[1:-1] = 1
# 切片赋值 brr1 -> {0,1,1,...,1,999}
brr1 = np.array(range(1000))
# 切片取值 brr1[[0, 2, 0, 3]] -> {0, 2, 0, 3}
brr6 = brr1 * brr1
brr7 = (brr1 + 1) ** 2
# 集体数值运算 brr6 -> {0, 1, 4, 9, 16, ...}
# 集体数值运算 brr7 -> {1, 4, 9, 16, ...}
```
容易发现，相比于 python 原生的 list，numpy 的 array 语法规范更接近于数学意义上的“数组”，这也是为什么 python 中很少有人将原生的 list 称为数组的原因（你很难想象在 C++/Java 中会有人用“数组”这个词语专门指代一个第三方工具库规定的数据类型），通常人们习惯于用 list 的英文原意“列表”来指代原生语法的数组，而用“数组”来指代 numpy 语法的同一事物。

之所以花费如此篇幅去解释 numpy 的语法规范，是因为这些优雅的语法规范是完成旋转算法的关键。
现在我们确定了如下步骤：
  1. 通过预定的旋转角度 e，计算出旋转变换矩阵 A
  2. 通过变换矩阵 A，利用 numpy 工具库计算坐标阵列 G
  3. 通过坐标阵列 G，利用 numpy 工具库从原图中选择若干像素映射至旋转图

让我们试着来完成它：
```
# 变换矩阵
sine = np.sin(e)
cose = np.cos(e)
A = np.array([
  [cose, -sine],
  [sine,  cose],
])
# 坐标阵列
R = np.arange(L)
G = np.meshgrid(R, R) - L//2
G = np.stack([G, G.T], axis=2)
G = np.dot(G, A)
# 映射
G = G.astype(np.int32)
result = image[
  G[:, :, 1] + L//2 + Py,
  G[:, :, 0] + L//2 + Px,
]
```
如果说，只需掌握高中数学的知识，就能够用原生 python 完成图像的旋转，这并非天方夜谭，但显然无法兼顾效率与优雅。相比之下，如若掌握了大学中有关矩阵的知识，再辅以 numpy 工具库，则可以简洁且高效的实现同样功能。下面让我们来简单解释一下这几行代码的作用（虽然我没有测试运行）。
  1. 我们预设了五个变量，分别是 旋转角度 e 、目标数组长度 L、原图数组 image、原图坐标偏移 Px、Py
  2. 我们首先根据旋转角度 e，计算出了旋转变换矩阵 A，这不消耗计算量
  3. 我们随后生成了一个坐标变换阵列 G，这具有 L^2 的内存和时间复杂度
  4. 我们通过计算张量积淀方式对 G 进行了旋转变换，这需要 L^2 的内存和时间复杂度
  5. 我们通过切片选择语法从原图数组中选择出组成目标数组的元素，这需要 L^2 的内存和时间复杂度

现在让我们回顾一下 opencv：
  1. 当使用它旋转图像时，我们总是在进行全图旋转，以最坏的情况（45°）为例，若要保证旋转后能截定一个长度为 L 的目标数组（无黑边），我们必须准备一个长度为 2L 的原图数组进行旋转，这直接产生了 4 倍的冗余计算。
  2. opencv 只能处理纯图像格式（uint8[0, 255] 或 float32[0, 1] && channel in {0, 1, 3}），但我们将旋转的内容却未必只是这些（例如当你预处理数据时，image 和 label 总是同时旋转，但 label 长什么样只有鬼知道）
  3. opencv 默认采用双线性插值执行仿射变换，但诸如 label 这种东西显然必须采用最近邻法插值填充，至于说其它奇形怪状的待变换张量，那可能已经超出了 opencv 的识别能力。

总的来说，opencv 是一个 very-good 的图像处理工具库，但它仅仅适用于图像处理本身，一旦遇到类似于图像、却又不完全相同的业务需求，它那固执呆板的 API 就会变成 debug 的负担。

## 二、接口设计

谢天谢地，我们仍记得这篇文章不只是关于 opencv 和旋转算法的吐槽：作为一个工具库，在顾及功能实现与算法效率之余，我们仍应当设计出一个简洁易用的接口以供调用，我猜没有人会希望每次调用一个工具库函数之前都不得不计算和提供一大堆乱七八糟的参数，我们总是更倾向于提供现成的数据。

现在让我们假设自己是用户程序员，我们的业务需求是从一张 （int(1e9), int(1e9), 3）-> uint8[0, 255] 的超级大图中截定坐标区域为 [5000:6000, 5000:6000] 的子图，这当然需要一些额外的工具，例如 openslide，不过这里还有一些其它需求：
  1. 我们发现这张超级大图在拍摄时歪了 15°，我们希望你在截图时能将它旋转回来
  2. 我们并不需要一张 （1000, 1000） 的图片，如果可以的话，将它缩放至 （100, 100）

上述的需求1并不明确，我们可以将它理解为“截定目标区域内旋转15°的最大矩形数组”，但这样一来，目标数组的长度就成了变化量，我们通常不会希望目标数组的长度是随机值；我们也可以将其理解为“将目标区域旋转15°后作为待截定的目标区域”，尽管描述起来费劲，但它想象起来却是简洁而直观的。因此，我们为后一种理解开设了接口。

当结合需求2时，问题变得更加捉摸不定：我们究竟是在放大一张图片，还是在缩小一张图片？事实上，放大和缩小都是相对而言的，我们需要先固定自己的视角，然后才能谈论放大和缩小。若将视角锁定于原图的变换过程，显然，一张（1000, 1000）的图片变换为（100, 100）是缩小了；若将视角锁定于坐标阵列，我们用（100, 100）的坐标阵列去仿射（1000, 1000）的图片，坐标阵列显然放大了。依据项目惯例，我们采用的是后一种解释。

现在，让我们确定一下接口的样式（伪代码）：
```
Cut(image, position, size, degree, scale) -> target
```
依据上述分析，我们明确了 size、degree、scale 的含义，显然 target.shape == size，但 position 仍缺乏定义。为此，我们开通了两个接口规范：
```
Cut1[image, x_start: x_end, y_start: y_end, degree, scale]
Cut2(image, (x_center, y_center), (x_size, y_size), degree, scale)
```
规范1 使用切片语法，通过 (x_start, y_start, x_end, y_end) 划定目标区域，并对这个目标区域进行旋转和放缩。规范2 是一个函数，通过 (x_center, y_center) 指定区域中心，再根据（x_size, y_size）划定目标区域，并进行旋转和放缩。

现在让我们回忆一下这个工具库的作用：从原图数组中旋转切取不同的子图。如果你还记得之前 L=int(1e9) 的例子，大概就能想到，这样的超级大图根本不可能一次性加载到内存之中，我们需要诸如 openslide 这样的工具，而一旦使用第三方工具，我们就必须针对 image 的不同可能性（numpy、Image或其它）进行适配，这个工作量是灾难性的。

因此，我们使用继承与多态的方法来重构它。
```
class Cut:
  # 规范1 -> [x_start: x_end, y_start: y_end, degree, scale]
  def __getitem__(self, items):
    pass
  # 规范2 -> (x_center, y_center), (x_size, y_size), degree, scale
  def get(pos, size, degree, scale):
    pass
  # 数据源 -> (x_start, y_start), (x_size, y_size)
  def slide(pos, size):
    pass
```
其上，_ _ getitem _ _ 是 python 的魔法函数，用于实现切片语法，get 是上文算法的直接实现，而 slide 则是从数据源中截定原图数组的一个抽象方法 -> 换而言之，Cut 不应该被单独使用。当我们需要引用该算法时，必须先继承 Cut，然后实现它的 slide 方法，具体的实现方法与数据源的存在形式有关，它可以是 numpy，可以是Image，也可以在硬盘而非内存上，无论它长什么样，我们只要根据 pos 和 size 返回它的一个子集即可。这样做的意义在于，规避了由纷繁复杂的数据源引起的代码混乱，数据源甚至可以是临时生成的，而对旋转切图算法本身不会有任何不利的影响。

最后，为了验证我们旋转切图方法的正确性（来自另一个工具库的需求，名为魔法迭代），我们还设计了一个小函数，用于将已经旋转过的图片再转回去，与 opencv（似乎拖出来pk已成日常？）相比，它的特点是旋转前后图像尺寸增大、仍旧由矩形区域包含、矩形区域中包含完整的原数组。 -- TODO --此处空口描述甚是费力，应当贴图展示效果 -- TODO --

## 三、容差矫正

经过算法设计、接口设计，我们已经在事实上得到了一个可用的工具库，但作为工具库，如果仅满足于“高效便捷的实现功能”，那就实在低估了用户的破坏力 —— 尽管在这个场景下，我们是自己的用户。一个工具库必须做到健壮可靠，它必须妥善处理各式各样的边界问题。

索性 numpy 帮我们健壮可靠的处理了数组越界 bug，但当取值于边界时，它所截定返回的目标数组就不再是我们预设的形状，这将导致后续运算中出现数组不对齐的错误；当计算旋转和缩放时，也存在某种可能，数值因取整误差恰好大于 L 或 小于 0；即便上述问题处理妥善了，若两张所截区域相邻的图不能拼回一张完整图像，那也是业务逻辑有错的。

这些容差问题上的矫正并不需要什么特定的工具或算法，只能说，这是工程代码中最薄弱的一环，也是最应当花大精力完善的部分。

以上就是本工具库的全部介绍，更多详情及代码请参照 -- TODO -- 这里应该做一个跳转链接，指向代码 -- TODO --
 -- TODO -- 上一篇 -- TODO -- 
 -- TODO -- 下一篇 -- TODO -- 
 -- TODO -- 首  页 -- TODO -- 
 
