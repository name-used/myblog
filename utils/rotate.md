# 旋转-缩放通用工具库

设计目的：
  实现以任意角度、任意缩放进行原图采样[1]的通用工具
  
子结构：
  1. 旋转缩放算法
  2. 接口设计
  3. 边界矫正
  4. 零一误差矫正

## 一、旋转缩放算法

事实上，图像的旋转变换是一个非常简单的数学运算，同时，早已有大量现成的工具库可以使用[2]。
首先让我们回到高中，设 XOY 平面上有坐标点 P0=(x0, y0)，我们知道它可以用极坐标表示为 P =（r, a），并满足：
```
x0 = r * cosa, y0 = r * sina, r = sqrt(x0*x0 + y0*y0), a = arctan(y0/x0)
```
现令 P0 绕原点逆时针旋转至 P=(x,y) 处，不妨设旋转角度 e，则其极坐标为 P=（r, a+e），由坐标间对应关系可知，其依然满足：
```
x = r * cos(a+e), y = r * sin(a+e)
```
我们将三角函数展开，可得如下表达式：
```
x = r * cosa * cose - r * sina * sine
y = r * sina * cose + r * cosa * sine
```
由几何关系不难发现，上式中的 r * sina 恰表示 y0；r * cosa 恰表示 x0，因此进一步简化，得：
```
x = x0 * cose - y0 * sine
y = y0 * cose + x0 * sine
```
现在让我们进入大学，学过线性代数或高等代数的人显然不会对上式感到陌生，这是一个典型的线性变换，可记作：
```
P = A × P0
其中，A = [
  cose   -sine
  sine    cose
]
```
式中， P(x,y) 随 P0(x0,y0) 变化，变化法则被矩阵 A 所唯一确定，类似这样的变换统一称为 “仿射变换” -> Affine
显然，旋转是一种仿射变换，但仿射变换不止包含旋转，事实上，本工具库可以封装任何类型的仿射变换，但本人只用到了旋转和缩放，因此对其它变换未提供支持。
接着让我们进入码农们的世界，前文提到，图像的旋转变化早已有大量的现成的工具库可以使用，其中最著名的工具当之无愧是 opencv，它可以通过这样的代码旋转一张图片：
```
cv2.rotate(src=image, rotateCode=cv2.ROTATE_90_COUNTERCLOCKWISE)
或
M = cv2.getRotationMatrix2D(center=(x0, y0), degree=90, scale=1)
cv2.warpAffine(src=img, M=M, dsize=(h, w))
```
只是看到这样糟糕的代码封装，大概你就能意识到为何我会放弃它，而选择手写一个旋转函数了：
  1. opencv 作为原生于 C++ 语言的工具库，其封装语法更接近程式性语言，而非面向对象或函数式的
  2. opencv 显式支持的 rotate 函数只提供 90° 旋转的功能
  3. opencv 通过仿射矩阵隐式支持旋转算法需要自行补充计算大量的外围参数
  4. 综上，手写一个旋转算法并不比直接应用 opencv 麻烦多少，性能上反而可能更高（这将在下文计算时间复杂度时进行解释）









