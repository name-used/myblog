# 旋转-缩放通用工具库

设计目的：
  实现以任意角度、任意缩放进行原图采样[1]的通用工具
  
子结构：
  1. 旋转缩放算法
  2. 接口设计
  3. 边界矫正
  4. 零一误差矫正

## 一、旋转缩放算法

事实上，图像的旋转变换是一个非常简单的数学运算，同时，早已有大量现成的工具库可以使用[2]。

首先让我们回到高中，设 XOY 平面上有坐标点 P0=(x0, y0)，我们知道它可以用极坐标表示为 P =（r, a），并满足：
```
x0 = r * cosa, y0 = r * sina, r = sqrt(x0*x0 + y0*y0), a = arctan(y0/x0)
```
现令 P0 绕原点逆时针旋转至 P=(x,y) 处，不妨设旋转角度 e，则其极坐标为 P=（r, a+e），由坐标间对应关系可知，其依然满足：
```
x = r * cos(a+e), y = r * sin(a+e)
```
我们将三角函数展开，可得如下表达式：
```
x = r * cosa * cose - r * sina * sine
y = r * sina * cose + r * cosa * sine
```
由几何关系不难发现，上式中的 r * sina 恰表示 y0；r * cosa 恰表示 x0，因此进一步简化，得：
```
x = x0 * cose - y0 * sine
y = y0 * cose + x0 * sine
```
现在让我们进入大学，学过线性代数或高等代数的人显然不会对上式感到陌生，这是一个典型的线性变换，可记作：
```
P = A × P0
其中，A = [
  cose   -sine
  sine    cose
]
```
式中， P(x,y) 随 P0(x0,y0) 变化，变化法则被矩阵 A 所唯一确定，类似这样的变换统一称为 “仿射变换” -> Affine，显然，旋转是一种仿射变换，但仿射变换不止包含旋转，事实上，本工具库可以封装任何类型的仿射变换，但本人只用到了旋转和缩放，因此对其它变换未提供支持。

接着让我们进入码农们的世界，前文提到，图像的旋转变化早已有大量的现成的工具库可以使用，其中最著名的工具当之无愧是 opencv，它可以通过这样的代码旋转一张图片：
```
cv2.rotate(src=image, rotateCode=cv2.ROTATE_90_COUNTERCLOCKWISE)
或
M = cv2.getRotationMatrix2D(center=(x0, y0), degree=90, scale=1)
cv2.warpAffine(src=img, M=M, dsize=(h, w))
```
只是看到这样糟糕的代码封装，大概你就能意识到为何我会放弃它，而选择手写一个旋转函数了：
  1. opencv 作为原生于 C++ 语言的工具库，其封装语法更接近程式性语言，而非面向对象或函数式的
  2. opencv 显式支持的 rotate 函数只提供 90° 旋转的功能
  3. opencv 通过仿射矩阵隐式支持旋转算法需要自行补充计算大量的外围参数
  4. 综上，手写一个旋转算法并不比直接应用 opencv 麻烦多少，性能上反而可能更高（这将在下文计算时间复杂度时进行解释）

在继续之前，先让我们来熟悉一下 python 中的另一个神级工具库：numpy。numpy 同样是 c++ 写成的第三方工具库，不同之处在于，它是完全以 python 语法为基础进行封装的，这意味着它的使用更加便捷与灵活，尤为重要的是，它定义了一种全新的python规范，这种规范被广泛接纳于全部与 python 有关的代数计算领域，应该说，很少能见到不依赖于 numpy 的科学计算工具库，当然，包括opencv也是 -> 它的参数、返回值都是 numpy.ndarray 类型。

让我们来对比一下 numpy 和原生 python 之间的异同
```
# ----------------- 原生 ------------------
arr1 = list(range(1000))
arr2 = arr1 + arr1
# 列表相加 len(arr2) == 2 * len(arr1)
arr3 = arr1 * 5
# 列表数乘 len(arr2) == 5 * len(arr1)
arr4 = [
  [1, 2],
  [3, 4],
]
# 二维列表取值 arr4[0][1]
arr5 = arr1[1:-1]
# 切片取值 len(arr5) == len(arr1) - 2
arr1[1:-1] = []
# 切片赋值 len(arr1) == 2

# ----------------- numpy ------------------
brr1 = np.array(range(1000))
brr2 = brr1 + brr1
# 数组相加 brr2 -> {0, 2,4,6,...}
brr3 = brr1 * 5
# 数组数乘 brr3 -> {0, 5,10,15,...}
brr4 = np.array([
  [1, 2],
  [3, 4],
])
# 二维数组取值 brr4[0, 1]
brr5 = brr1[1:-1]
# 切片取值 len(brr5) == len(brr1) - 2
brr1[1:-1] = 1
# 切片赋值 brr1 -> {0,1,1,...,1,999}
brr1 = np.array(range(1000))
# 切片取值 brr1[[0, 2, 0, 3]] -> {0, 2, 0, 3}
brr6 = brr1 * brr1
brr7 = (brr1 + 1) ** 2
# 集体数值运算 brr6 -> {0, 1, 4, 9, 16, ...}
# 集体数值运算 brr7 -> {1, 4, 9, 16, ...}
```
容易发现，相比于 python 原生的 list，numpy 的 array 语法规范更接近于数学意义上的“数组”，这也是为什么 python 中很少有人将原生的 list 称为数组的原因（你很难想象在 C++/Java 中会有人用“数组”这个词语专门指代一个第三方工具库规定的数据类型），通常人们习惯于用 list 的英文原意“列表”来指代原生语法的数组，而用“数组”来指代 numpy 语法的同一事物。

之所以花费如此篇幅去解释 numpy 的语法规范，是因为这些优雅的语法规范是完成旋转算法的关键。
现在我们确定了如下步骤：
  1. 通过预定的旋转角度 e，计算出旋转变换矩阵 A
  2. 通过变换矩阵 A，利用 numpy 工具库计算坐标阵列 G
  3. 通过坐标阵列 G，利用 numpy 工具库从原图中选择若干像素映射至旋转图

让我们试着来完成它：
```
# 变换矩阵
sine = np.sin(e)
cose = np.cos(e)
A = np.array([
  [cose, -sine],
  [sine,  cose],
])
# 坐标阵列
R = np.arange(L)
G = np.meshgrid(R, R) - L//2
G = np.stack([G, G.T], axis=2)
G = np.dot(G, A)
# 映射
G = G.astype(np.int32)
result = image[
  G[:, :, 1] + L//2 + Py,
  G[:, :, 0] + L//2 + Px,
]
```
如果说，只需掌握高中数学的知识，就能够用原生 python 完成图像的旋转，这并非天方夜谭，但显然无法兼顾效率与优雅。相比之下，如若掌握了大学中有关矩阵的知识，再辅以 numpy 工具库，则可以简洁且高效的实现同样功能。下面让我们来简单解释一下这几行代码的作用（虽然我没有测试运行）。
  1. 我们预设了五个变量，分别是 旋转角度 e 、目标数组长度 L、原图数组 image、原图坐标偏移 Px、Py
  2. 我们首先根据旋转角度 e，计算出了旋转变换矩阵 A，这不消耗计算量
  3. 我们随后生成了一个坐标变换阵列 G，这具有 L^2 的内存和时间复杂度
  4. 我们通过计算张量积淀方式对 G 进行了旋转变换，这需要 L^2 的内存和时间复杂度
  5. 我们通过切片选择语法从原图数组中选择出组成目标数组的元素，这需要 L^2 的内存和时间复杂度

现在让我们回顾一下 opencv：
  1. 当使用它旋转图像时，我们总是在进行全图旋转，以最坏的情况（45°）为例，若要保证旋转后能截定一个长度为 L 的目标数组（无黑边），我们必须准备一个长度为 2L 的原图数组进行旋转，这直接产生了 4 倍的冗余计算。
  2. opencv 只能处理纯图像格式（uint8[0, 255] 或 float32[0, 1] && channel in {0, 1, 3}），但我们将旋转的内容却未必只是这些（例如当你预处理数据时，image 和 label 总是同时旋转，但 label 长什么样只有鬼知道）
  3. opencv 默认采用双线性插值执行仿射变换，但诸如 label 这种东西显然必须采用最近邻法插值填充，至于说其它奇形怪状的待变换张量，那可能已经超出了 opencv 的识别能力。

总的来说，opencv 是一个 very-good 的图像处理工具库，但它仅仅适用于图像处理本身，一旦遇到类似于图像、却又不完全相同的业务需求，它那固执呆板的 API 就会变成 debug 的负担。






