# 魔法迭代专用工具

设计目的：
  实现自适应原图采样[1]的专用工具
  
子结构：
  1. 设计理念
  2. 设计原理
  3. 高级迭代

## 一、设计理念

首先让我们模拟这样一个场景：在一张（1000, 1000）的风景照上，有一个区域包含人群，我们希望尽可能多从这些人群区域采集素材，而尽可能少的从其它区域采集，为此，我们预先标定一个矩形的目标区域（或近似矩形的单联通区域） -> 现在，我们只需要在目标区域内进行采样即可。

现在问题来了，怎样才能合理遍历这个矩形区域呢？

在讨论怎样设计之前，我们需要明确一下什么是“合理”：
  1. 目标区域之中的像素应当仅被采集一次
  2. 目标区域之外的像素不应该被采集
  3. 任何情况下，采集区域不能超越图像的边界

目标1保证了采样的均匀性，目标2排除了那些不期望被选择的“脏样本”，目标3则保证了采样方法的可用性。

让我们回到小学，列一个简单的表达式：
```
设木板长度 L，将其截断为长度 x 的短板，总共能截出几段？
L = n * x + r
上式，n表示截出的段数，r表示剩余木板的长度。
若我们期待这个表达式有意义，需额外规定 0 <= r < x，这样一来，它就表达了“ L 除以 x 得 n 余 r ”的数学含义。
显然，该数学含义亦对应着“长 L 的木板截出 n 段长 x 的短板后余长 r ”的应用含义。
该表达式说明：
木板余长 r 被木板长度 L 和短板长度 x 所唯一确定。
```
目标区域是依据图像标定的，不是一个可变量；采样的窗口尺寸通常受制于模型本身，也不是一个可变量；而现在，我们期待余长 r==0 。

受限于客观因素，上述目标无法同时实现，因此只好对“合理性”做出妥协：
  1. 目标区域之中的像素至少被采集一次
  2. 目标区域之外的像素至多被采集一次
  3. 目标区域之中的采样两次的像素越少越好，且应均匀分布于目标区域各处
  4. 目标区域之外的采样一次的像素越少越好，且应当尽可能临近目标区域
  5. 任何情况下，采集区域不能超越图像的边界

现在，一个初通算法的中学生也清楚如何解决该问题了。

## 二、设计原理

我们仍试图将“题解”展示出来:
```
显然该问题中，X方向与Y方向对称，解决其一即可，仍用 L = n * x + r 表示，考虑极端情况：
  1. 若图像边界无穷远（目标5不产生实际影响），则令 L' = L + x - r，显然 L' = (n+1) * x
  2. 若图像边界为0（目标2、目标4不产生实际影响），则令 x' = (L + r) / n，显然 L = n * x'
上两式均满足 r' == 0，前式 L'-L 表示超界采样的长度，后式 x-x' 表示窗口尺寸缩小的长度。
```
前文提到，L 受制于图像本身的特征，而 x 受制于模型的需要，二者皆不可变，因此，应用该算法时需首先结合自身业务的敏感特征，以决定是否采用该算法、或如何应用该算法。

我们做出的选择是：在可能的情况下，优先调整 L -> L'，并将 L 对应的标定区间两端均匀扩展，除非触及图像的边界；直至 L' 扩张至图像边界而仍无法满足需求时，调整 x -> x'，但缩小的仅仅是步长，原窗口尺寸保持不变，从而在图像中的个别局部产生重叠。

如果上述原理都已经看懂，那么事实上这个算法你已经掌握了，现在尝试自己去实现它吧~！

尽管魔法迭代的原理并不复杂，它的工程实现却有些难度，这既包括坐标间的坐标变换，也包括边界处理和零一误差问题，这些细节我们将在代码的注释间予以详细解释。

## 三、高级迭代

现在让我们玩一点大人的游戏：我们需要在这一区域重复采样若干次，我们期待每次的采样结果都能有所变化，同时仍近似确保“合理性”。一个容易想到的方法是：
```
L = random(n*x, (n+1)*x)
```
应当说这毫无难度，并且随着 L 的改变，我们无需修订上述算法计算过程的任何一环而能给出均匀分布的随机变换，唯一的问题是，它仍然必须是横平竖直的。

是的，我们期待将“旋转”的功能增加进来。

如果你还记得上一篇关于“旋转”的工具库（PS：我实在不明白为什么“工具库”这三个字在我的输入法中总是呈现为“工具哭”），没错，那就是我们需要的东西。通过 utils/rotate，我们可以很方便的从原图中截定一个旋转的给定区域，现在只差一个问题了：这个“指定区域”应该如何给定？

我们先考虑这样一个问题：用一组旋转15°的正方形平铺目标区域，如何铺设才能做到不重且尽量不漏？
 -- TODO -- 将demo/readme中的图片贴过来 -- TODO -- 

如上图示，妄图用旋转过的矩形平铺整个目标区域，这种铺法显然是最优解（它不一定在数学上最优，但其它数学解难以编程实现），在这种铺设方法里，x方向和y方向失去了对称性，我们容易看到，黑色标定的旋转矩形在y方向是密铺的，而在x方向是错落的；蓝框标定的外接矩形则在x方向重叠密铺，在y方向错落 -> 显然，蓝框更方便沿袭我们魔法迭代的思路，现在我们需要计算它的密铺参数：
-- TODO -- 将demo/readme中的图片贴过来 -- TODO -- 

通过上图计算，我们轻松得到了外接矩形的密铺参数，然后进一步将它分解为编程实现所依赖的变换参数：
-- TODO -- 将demo/readme中的图片贴过来 -- TODO -- 

现在我们得到了外接矩形的密铺参数，相较于原方案，含旋转的切图方法最大特点是y方向每次迭代都产生一个固定的水平偏移qx。当我们的图像足够大时，迭代到一定次数后，由水平偏移qx产生的位移将足以放下一个新的采样区间，因而它需要记录 x 方向的锚点，每行采样结束时，下一行的锚点将先偏移qx，再对窗口的大小取余，这将在代码里以详尽的注释进行解释。

现在我们成功对外接矩形实现了平铺和魔法迭代，但似乎还有一件事情没有完成：我们真正需要的是旋转矩形的参数，这些参数将结合 utils/rotate 一同实现旋转采样。
-- TODO -- 将demo/readme中的图片贴过来 -- TODO -- 

让我们来观察上图，黑框区域就是我们的外接矩形，而蓝色区域和红色区域一同反向旋转了15°（还记得旋转切图工具库中关于图像旋转小方法的描述吗？），这就是它在原图中 rotate 的采样参数。由于我们计算的坐标隶是黑框区域，而我们返回的坐标是红框区域，因此还需对坐标做一个偏移，好在这个偏移量很容易计算（黑框变长减红框边长再除以二），最后我们将所有的采样结果拼接起来：
-- TODO -- 将demo/readme中的图片贴过来 -- TODO -- 

这就是魔法迭代与旋转切图的完美结合啦~！

如果你觉着哪些地方有点奇怪，你是对的，事实上，这个“高级迭代”与“魔法迭代”完全无关，但它在y轴方向应用了魔法迭代算法，而在x轴方向，事实上，也有办法将魔法迭代融入其中，只是因为过于复杂，我放弃了对它的支持。

最后，“高级迭代”和“魔法迭代”显然具有相同的目的：以“合理的”方式对原图进行采样。这也是它们最终被放在一起的原因。

以上就是本工具库的全部介绍，更多详情及代码请参照 -- TODO -- 这里应该做一个跳转链接，指向代码 -- TODO --
 -- TODO -- 上一篇 -- TODO -- 
 -- TODO -- 下一篇 -- TODO -- 
 -- TODO -- 首  页 -- TODO -- 
